# Python SSL certificate conversion tool.
# Download and converts SSL certs from PEM format into a C header that can be
# referenced from a sketch to load the certificate data (in binary DER format).
# Author: Tony DiCola
#
# Dependencies:
#   click - Install with 'sudo pip install click' (omit sudo on windows)
#   PyOpenSSL - See homepage: https://pyopenssl.readthedocs.org/en/latest/
#               Should just be a 'sudo pip install pyopenssl' command, HOWEVER
#               on Windows you probably need a precompiled binary version.  Try
#               installing with pip and if you see errors when running that
#               OpenSSL can't be found then try installing egenix's prebuilt
#               PyOpenSSL library and OpenSSL lib:
#                 http://www.egenix.com/products/python/pyOpenSSL/
#
import os
import socket
import ssl
import textwrap

import click
from OpenSSL import crypto, SSL

# Default values:
CERT_LEN_VAR_DEFAULT = 'ROOTCA_CERTS_LEN'  # Cert data length variable name.
CERT_VAR_DEFAULT = 'rootca_certs'          # Cert data variable name.

# Template that defines the C header output format.
# This takes in a few named parameters:
#  - guard_name: Unique name to apply to the #ifndef header guard.
#  - cert_length_var: Variable/define name for the length of the certificate.
#  - cert_length: Length of the certificate (in bytes).
#  - cert_var: Variable name for the certificate data.
#  - cert_data: Certificate data (must be in comma separated hex format).
#  - cert_description: Any descriptive info about the certs to put in comments.
# NOTE: If you're changing the template make sure to escape all curly braces
# with a double brace (like {{ or }}) or else Python will try to interpret as a
# string format variable.
CFILE_TEMPLATE = """\
#ifndef _{guard_name}_H_
#define _{guard_name}_H_

#ifdef __cplusplus
extern "C"
{{
#endif

/* This file is auto-generated by the pycert tool.  Do not change it manually.
   Certificates are in DER (binary) format.  Included certs:
{cert_description}
*/
#define {cert_length_var} {cert_length}
const uint8_t {cert_var}[{cert_length_var}] = {{
{cert_data}
}};

#ifdef __cplusplus
}} /* extern "C" */
#endif

#endif /* ifndef _{guard_name}_H_ */
"""

# Useful helper functions:
def get_server_cert_chain(address, port):
    """Attempt to retrieve the full SSL cert chain from the provided server
    address & port.  Will return a list with the full cert chain as PyOpenSSL
    X509 objects, or None if the chain couldn't be retrieved for some reason.
    """
    # Use PyOpenSSL to initiate an SSL connection and get the full cert chain.
    # Sadly Python's built in SSL library can't do this so we must use this
    # OpenSSL-based library.
    ctx = SSL.Context(SSL.SSLv23_METHOD)
    soc = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    ssl_soc = SSL.Connection(ctx, soc)
    ssl_soc.connect((address, port))
    try:
        ssl_soc.do_handshake()
        return ssl_soc.get_peer_cert_chain()
    finally:
        ssl_soc.shutdown()
        soc.close()

def PEM_description(cert_pem):
    """Return a string that describes the provided PEM certificate in a human
    readable format.
    """
    cert = crypto.load_certificate(crypto.FILETYPE_PEM, cert_pem)
    subject = '/'.join(map(lambda x: '{0}={1}'.format(x[0], x[1]), cert.get_subject().get_components()))
    issuer = '/'.join(map(lambda x: '{0}={1}'.format(x[0], x[1]), cert.get_issuer().get_components()))
    notAfter = str(cert.get_notAfter())
    return 'subject={0} issuer={1} notAfter={2}'.format(subject, issuer, notAfter)

def cert_to_header(cert_data, output_file, cert_var, cert_length_var, cert_description):
    """Convert binary certificate data into a C header that will import and expose the
    certificate to a sketch.  Cert_data should be a binary string with certificate
    data in DER format, and output_file should be a file that is open for writing
    and will receive the result header file data.
    """
    # Build up the header template text parameters for the output.
    params = {}
    # Set header guard to output file name in uppercase and without .h extension.
    params['guard_name'] = os.path.splitext(output_file.name)[0].upper()
    # Set other template values.
    params['cert_length_var'] = cert_length_var
    params['cert_var'] = cert_var
    params['cert_length'] = len(cert_data)
    params['cert_description'] = cert_description
    # Convert DER to hex byte string with each byte separated by a comma
    # (so it can be used in an array definition).
    cert_hex = ', '.join(['0x{0:02X}'.format(x) for x in cert_data])
    # Set cert data to hex string (wrapped nicely on 80 character boundary).
    params['cert_data'] = textwrap.fill(cert_hex, width=80, break_long_words=False,
        break_on_hyphens=False, initial_indent='  ', subsequent_indent='  ')
    output_file.write(CFILE_TEMPLATE.format(**params))

def PEM_split(cert_pem):
    """Split a certificate / certificate chain in PEM format into multiple
    PEM certificates.  This is useful for extracting the last / root PEM cert
    in a chain for example.  Will return a list of strings with each string
    being an individual PEM certificate (including its '-----BEGIN CERTIFICATE...'
    delineaters).
    """
    # Split cert based on begin certificate sections, then reconstruct as an
    # array of individual cert strings.
    delineator = '-----BEGIN CERTIFICATE-----'
    return ["{0}{1}".format(delineator, x) for x in cert_pem.strip().split(delineator) if x != '']

def PEM_to_header(pems, cert_var, cert_length_var, output, full_chain, keep_dupes):
    """Combine a collection of PEM format certificates into a single C header with the
    combined cert data in binary DER format.  Pems should be a list of strings with
    each cert PEM or chain of PEM certs, cert_var controls the name of the cert data
    variable in the output header, cert_length_var controls the name of the cert
    data length variable/define, output is the output file (which must be open for
    writing), and full_chain is a boolean that indicates if each cert chain should include
    the full chain or just the root/last cert.  Keep_dupes is a boolean to
    indicate if duplicate certificates should be left intact (true) or removed (false).
    """
    cert_der = bytearray()
    cert_description = ''
    processed_certs = set()
    for p in pems:
        certs = PEM_split(p)
        if full_chain:
            # Go through each cert in the chain and convert to DER format.
            for cert_pem in certs:
                # Skip duplicate certs where required.
                if not keep_dupes and cert_pem in processed_certs:
                    continue
                processed_certs.add(cert_pem)
                cert_description += '    {0}\n'.format(PEM_description(cert_pem))
                cert_der.extend(bytearray(ssl.PEM_cert_to_DER_cert(cert_pem)))
        else:
            # Otherwise just grab the last cert in the chain (the root) and convert.
            cert_pem = certs[-1]
            # Skip duplicate certs where required.
            if not keep_dupes and cert_pem in processed_certs:
                continue
            processed_certs.add(cert_pem)
            cert_description += '    {0}\n'.format(PEM_description(cert_pem))
            cert_der.extend(bytearray(ssl.PEM_cert_to_DER_cert(cert_pem)))
    # Save DER cert data as a C style header.
    cert_to_header(cert_der, output, cert_var, cert_length_var, cert_description)
    click.echo('Wrote {0}'.format(output.name))


# Click setup and commands:
@click.group()
def pycert():
    """Adafruit Python Certificate Tool

    This is a tool to download and convert SSL certificates and certificate
    chains into a C header format that can be imported into WICED board sketches.
    """
    pass

@pycert.command(short_help='Download SSL certs and save as a C header.')
@click.option('--port', '-p', type=click.INT, default=443,
              help='port to use for reading certificate (default 443, SSL)')
@click.option('--cert-var', '-c', default=CERT_VAR_DEFAULT,
              help='name of the variable in the header which will contain certificate data (default: {0})'.format(CERT_VAR_DEFAULT))
@click.option('--cert-length-var', '-l', default=CERT_LEN_VAR_DEFAULT,
              help='name of the define in the header which will contain the length of the certificate data (default: {0})'.format(CERT_LEN_VAR_DEFAULT))
@click.option('--output', '-o', type=click.File('w'), default='certificates.h',
              help='name of the output file (default: certificates.h)')
@click.option('--full-chain', '-f', is_flag=True, default=False,
              help='use the full certificate chain and not just the root/last cert (default: false, root cert only)')
@click.option('--keep-dupes', '-d', is_flag=True, default=False,
              help='write all certs including any duplicates across domains (default: remove duplicates)')
@click.argument('domain', nargs=-1)
def download(port, cert_var, cert_length_var, output, full_chain, keep_dupes, domain):
    """Download the SSL certificates for specified domain(s) and save them as a C
    header file that can be imported into a sketch.

    Provide at least one argument that is the domain to query for its SSL
    certificate, for example google.com for Google's SSL certificate.  You can
    provide any number of domains as additional arguments.  All of the certificates
    will be combined into a single output header.

    By default the file 'certificates.h' will be created, however you can change
    the name of the file with the --output option.

    If a chain of certificates is retrieved then only the root certificate (i.e.
    the last in the chain) will be saved.  However you can override this and
    force the full chain to be saved with the --full-chain option.

    Example of downloading google.com's SSL certificate and storing it in
    certificates.h:

      pycert download google.com

    Example of downloading google.com and adafruit.com's SSL certificates and
    storing them in data.h:

      pycert download --output data.h google.com adafruit.com

    Note that the certificates will be validated before they are downloaded!
    """
    # Download the cert PEM for each provided domain.
    pems = []
    for d in domain:
        # Download the certificate (unfortunately python will _always_ try to
        # validate it so we have no control over turning that off).
        chain = get_server_cert_chain(d, port)
        if chain is None:
            raise click.ClickException('Could not download and/or validate the certificate chain for {0} port {1}!'.format(d, port))
        click.echo('Retrieved certificate chain for {0}:'.format(d))
        # Convert cert to PEM format and build a description of the chain.
        chain_pem = ''
        for c in chain:
            cert_pem = crypto.dump_certificate(crypto.FILETYPE_PEM, c)
            click.echo('  ' + PEM_description(cert_pem))
            chain_pem += cert_pem
        pems.append(chain_pem)
    # Combine PEMs and write output header.
    PEM_to_header(pems, cert_var, cert_length_var, output, full_chain, keep_dupes)


@pycert.command(short_help='Convert PEM certs into a C header.')
@click.option('--cert-var', '-c', default=CERT_VAR_DEFAULT,
              help='name of the variable in the header which will contain certificate data (default: {0})'.format(CERT_VAR_DEFAULT))
@click.option('--cert-length-var', '-l', default=CERT_LEN_VAR_DEFAULT,
              help='name of the define in the header which will contain the length of the certificate data (default: {0})'.format(CERT_LEN_VAR_DEFAULT))
@click.option('--output', '-o', type=click.File('w'), default='certificates.h',
              help='name of the output file (default: certificates.h)')
@click.option('--full-chain', '-f', is_flag=True, default=False,
              help='use the full certificate chain and not just the root/last cert (default: false, root cert only)')
@click.option('--keep-dupes', '-d', is_flag=True, default=False,
              help='write all certs including any duplicates (default: remove duplicates)')
@click.argument('cert', type=click.File('r'), nargs=-1)
def convert(cert_var, cert_length_var, output, full_chain, keep_dupes, cert):
    """Convert PEM certificates into a C header that can be imported into a
    sketch.  Specify each certificate to encode as a separate argument (each
    must be in PEM format) and they will be merged into a single file.

    By default the file 'certificates.h' will be created, however you can change
    the name of the file with the --output option.

    If a chain of certificates is found then only the root certificate (i.e.
    the last in the chain) will be saved.  However you can override this and
    force the full chain to be saved with the --full-chain option.

    Example of converting a foo.pem certificate into a certificates.h header:

      pycert convert foo.pem

    Example of converting foo.pem and bar.pem certificates into data.h:

      pycert convert foo.pem bar.pem
    """
    # Load all the provided PEM files.
    pems = []
    for c in cert:
        cert_pem = c.read()
        click.echo('Loaded certificate {0}'.format(c.name))
        pems.append(cert_pem)
    # Combine PEMs and write output header.
    PEM_to_header(pems, cert_var, cert_length_var, output, full_chain, keep_dupes)


if __name__ == '__main__':
    pycert()
